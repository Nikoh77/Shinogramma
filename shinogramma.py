# This software (aka bot) is intended as a client to conveniently control Shinobi CCTV (more info at https://shinobi.video) through Telegram,
# right now it is possible to activate statuses but I'm working on it....
# I am Nikoh (nikoh@nikoh.it), if you think this bot is useful please consider helping me improving it on github 
# or donate me a coffee

from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler, CallbackContext, CallbackQueryHandler
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from functools import wraps
import ini_check
import logging
import requests
import inspect
import re

# Defining root variables
config_file = "config.ini"
settings = {}
commands = []
# Start logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.WARNING
)

def restricted(func):
    @wraps(func)
    def wrapped(update, context, *args, **kwargs):
        if not settings.get('Telegram').get('chat_id'):
            print('WARN: chat_id not defined, continuing...')
            return func(update, context, *args, **kwargs)
        user_id = update.effective_user.id
        if user_id not in settings['Telegram']['chat_id']:
            print("Unauthorized access denied for {}.".format(user_id))
            return
        return func(update, context, *args, **kwargs)
    return wrapped

# Telegram/Bot commands definition:
@restricted 
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    desc='Start this bot'
    context.user_data["originating_function"] = inspect.currentframe().f_code.co_name
    await context.bot.send_message(chat_id=update.effective_chat.id, text="I'm Shinotify Bot, and I am ready!\nGlad to serve you \u263A")

# Help is autogenerated parsing command functions
@restricted    
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    desc='Where you are'
    context.user_data["originating_function"] = inspect.currentframe().f_code.co_name
    help_text = "Available commands are:\n"
    for command in commands:
        help_text += f'{command["desc"]}\n'
    await context.bot.send_message(chat_id=update.effective_chat.id,text=help_text)

@restricted
async def monitors_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    desc='List all monitors'
    context.user_data["originating_function"] = inspect.currentframe().f_code.co_name
    url = f"{settings['Shinobi']['url']}:{settings['Shinobi']['port']}/{settings['Shinobi']['api_key']}/monitor/{settings['Shinobi']['group_key']}"
    response = requests.get(url).json()
    monitors = []
    for i in response:
        monitors.append(i['name'])
    if monitors:
        buttons = []
        for monitor in monitors:
            buttons.append([InlineKeyboardButton(monitor, callback_data=monitor)])
        reply_markup = InlineKeyboardMarkup(buttons)
        await context.bot.send_message(chat_id=update.effective_chat.id, text='Push one monitor:', reply_markup=reply_markup)
    else:
        print('No monitors found \u26A0\ufe0f')
        await context.bot.send_message(chat_id=update.effective_chat.id, text='No states found \u26A0\ufe0f')

@restricted
async def states_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    desc='List all states'
    context.user_data["originating_function"] = inspect.currentframe().f_code.co_name
    url = f"{settings['Shinobi']['url']}:{settings['Shinobi']['port']}/{settings['Shinobi']['api_key']}/monitorStates/{settings['Shinobi']['group_key']}"
    response = requests.get(url).json()
    states = []
    for i in response['presets']:
        states.append(i['name'])
    if states:
        buttons = []
        for state in states:
            buttons.append([InlineKeyboardButton(state, callback_data=state)])
        reply_markup = InlineKeyboardMarkup(buttons)
        await context.bot.send_message(chat_id=update.effective_chat.id, text='Push one state to activate:', reply_markup=reply_markup)
    else:
        print('No states found \u26A0\ufe0f')
        await context.bot.send_message(chat_id=update.effective_chat.id, text='No states found \u26A0\ufe0f')

@restricted 
async def callback_handler(update: Update, context: CallbackContext):
    query = update.callback_query
    selection = query.data
    origin = context.user_data["originating_function"]
    if origin=='states_command':
        url = f"{settings['Shinobi']['url']}:{settings['Shinobi']['port']}/{settings['Shinobi']['api_key']}/monitorStates/{settings['Shinobi']['group_key']}/{selection}"
    else:
        pass
    
    response = requests.get(url)
    if response.status_code != 200:
        print(f'something went wrong, request error \u26A0\ufe0f')
        await context.bot.send_message(chat_id=update.effective_chat.id, text=f'something went wrong, request error \u26A0\ufe0f')
    else:
        print(f'OK, {selection} done \U0001F44D')
        await context.bot.send_message(chat_id=update.effective_chat.id, text=f'OK, done \U0001F44D')

if __name__ == '__main__':
    needed = {'Telegram':['api_key'],'Shinobi':['api_key','group_key','url','port']}
    result = ini_check.iniCheck(needed,config_file)
    frame = inspect.currentframe()
    command_functions = [obj for name, obj in frame.f_globals.items() if inspect.isfunction(obj) and name.endswith("_command")]
    for function in command_functions:
        command=function.__name__.split('_')[0]
        name=function.__name__
        code=inspect.getsource(function)
        pattern = r'desc\s*=\s*["\'](.*?)["\']'
        desc=re.search(pattern, code)
        if not desc:
            print(f'WARN: {function.__name__} function has no description...')
            break
        else:
            data={'func':function, 'name':name, 'command':command, 'desc':'/'+command+' - '+desc.group(1)}
            commands.append(data)
            if command_functions.index(function)<len(command_functions)-1:
                continue
        if result:
            settings = ini_check.settings
            application = ApplicationBuilder().token(settings['Telegram']['api_key']).build()
            # CommandHandlers for commands are autogenerated parsing command functions
            callback_query_handler = CallbackQueryHandler(callback_handler)
            handlers=[callback_query_handler]
            for command in commands:
                handlers.append(CommandHandler(f'{command["command"]}', command["func"]))
                
            application.add_handlers(handlers)
            application.run_polling()
        else:
            print('INI file missed, please provide one.')

